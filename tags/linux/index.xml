<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 程序猿的小本本</title>
    <link>http://replace-this-with-your-hugo-site.com/tags/linux/</link>
    <description>Recent content in Linux on 程序猿的小本本</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>chennqqi@qq.com (chennqqi)</managingEditor>
    <webMaster>chennqqi@qq.com (chennqqi)</webMaster>
    <copyright>(c) 2016 gsymy.com.</copyright>
    <lastBuildDate>Tue, 25 Aug 2015 00:57:10 +0000</lastBuildDate>
    <atom:link href="http://replace-this-with-your-hugo-site.com/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux screen 命令详解(转)</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/25/linux-screen.html</link>
      <pubDate>Tue, 25 Aug 2015 00:57:10 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/25/linux-screen.html</guid>
      <description>&lt;p&gt;转&lt;a href=&#34;http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html&#34; target=&#34;_blank&#34;&gt;linux screen 命令详解 &amp;#8211; David_Tang &amp;#8211; 博客园&lt;/a&gt;&lt;/p&gt;

&lt;div id=&#34;home&#34;&gt;
  &lt;div id=&#34;main&#34;&gt;
    &lt;div id=&#34;mainContent&#34;&gt;
      &lt;div class=&#34;forFlow&#34;&gt;
        &lt;div id=&#34;post_detail&#34;&gt;
          &lt;div id=&#34;topics&#34;&gt;
            &lt;div class=&#34;post&#34;&gt;
              &lt;div class=&#34;postBody&#34;&gt;
                &lt;div id=&#34;cnblogs_post_body&#34;&gt;
                  &lt;p&gt;
                    &lt;strong&gt;一、背景&lt;/strong&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    系统管理员经常需要SSH 或者telent 远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;二、简介&lt;/strong&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;GNU Screen&lt;/strong&gt;是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。
                  &lt;/p&gt;
                  
                  &lt;ul&gt;
                    &lt;li&gt;
                      &lt;strong&gt;会话恢复&lt;/strong&gt;
                    &lt;/li&gt;
                  &lt;/ul&gt;
                  
                  &lt;dl&gt;
                    &lt;dd&gt;
                      只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行&lt;strong&gt;screen -r&lt;/strong&gt;就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令&lt;strong&gt;detach&lt;/strong&gt;，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。
                    &lt;/dd&gt;
                  &lt;/dl&gt;
                  
                  &lt;ul&gt;
                    &lt;li&gt;
                      &lt;strong&gt;多窗口&lt;/strong&gt;
                    &lt;/li&gt;
                  &lt;/ul&gt;
                  
                  &lt;dl&gt;
                    &lt;dd&gt;
                      在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。
                    &lt;/dd&gt;
                  &lt;/dl&gt;
                  
                  &lt;ul&gt;
                    &lt;li&gt;
                      &lt;strong&gt;会话共享&lt;/strong&gt;
                    &lt;/li&gt;
                  &lt;/ul&gt;
                  
                  &lt;dl&gt;
                    &lt;dd&gt;
                      Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。
                    &lt;/dd&gt;
                  &lt;/dl&gt;
                  
                  &lt;p&gt;
                    GNU&amp;#8217;s Screen 官方站点：&lt;a href=&#34;http://www.gnu.org/software/screen/&#34; target=&#34;_blank&#34;&gt;http://www.gnu.org/software/screen/&lt;/a&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;三、语法&lt;/strong&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    # screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;参数说明&lt;/strong&gt;&lt;br /&gt; 
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    -A 　将所有的视窗都调整为目前终端机的大小。&lt;br /&gt; -d &lt;作业名称&gt; 　将指定的screen作业离线。&lt;br /&gt; -h &lt;行数&gt; 　指定视窗的缓冲区行数。&lt;br /&gt; -m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。&lt;br /&gt; -r &lt;作业名称&gt; 　恢复离线的screen作业。&lt;br /&gt; -R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。&lt;br /&gt; -s 　指定建立新视窗时，所要执行的shell。&lt;br /&gt; -S &lt;作业名称&gt; 　指定screen作业的名称。&lt;br /&gt; -v 　显示版本信息。&lt;br /&gt; -x 　恢复之前离线的screen作业。&lt;br /&gt; -ls或&amp;#8211;list 　显示目前所有的screen作业。&lt;br /&gt; -wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;四、常用screen参数&lt;/strong&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    screen -S yourname -&gt; 新建一个叫yourname的session&lt;br /&gt; screen -ls -&gt; 列出当前所有的session&lt;br /&gt; screen -r yourname -&gt; 回到yourname这个session&lt;br /&gt; screen -d yourname -&gt; 远程detach某个session&lt;br /&gt; screen -d -r yourname -&gt; 结束当前session并回到yourname这个session
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;在每个screen session 下，所有命令都以 ctrl+a(C-a) 开始。&lt;/strong&gt;&lt;br /&gt; C-a ? -&gt; 显示所有键绑定信息&lt;br /&gt; C-a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口&lt;br /&gt; C-a n -&gt; Next，切换到下一个 window&lt;br /&gt; C-a p -&gt; Previous，切换到前一个 window&lt;br /&gt; C-a 0..9 -&gt; 切换到第 0..9 个 window&lt;br /&gt; Ctrl+a [Space] -&gt; 由视窗0循序切换到视窗9&lt;br /&gt; C-a C-a -&gt; 在两个最近使用的 window 间切换&lt;br /&gt; C-a x -&gt; 锁住当前的 window，需用用户密码解锁&lt;br /&gt; C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。&lt;br /&gt; C-a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。&lt;br /&gt; C-a w -&gt; 显示所有窗口列表&lt;br /&gt; C-a t -&gt; Time，显示当前时间，和系统的 load&lt;br /&gt; C-a k -&gt; kill window，强行关闭当前的 window&lt;br /&gt; C-a [ -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 vi 一样&lt;br /&gt; C-b Backward，PageUp&lt;br /&gt; C-f Forward，PageDown&lt;br /&gt; H(大写) High，将光标移至左上角&lt;br /&gt; L Low，将光标移至左下角&lt;br /&gt; 0 移到行首&lt;br /&gt; $ 行末&lt;br /&gt; w forward one word，以字为单位往前移&lt;br /&gt; b backward one word，以字为单位往后移&lt;br /&gt; Space 第一次按为标记区起点，第二次按为终点&lt;br /&gt; Esc 结束 copy mode&lt;br /&gt; C-a ] -&gt; Paste，把刚刚在 copy mode 选定的内容贴上
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;五、使用 screen&lt;/strong&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;strong&gt;5.1 安装screen&lt;/strong&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    流行的Linux发行版（例如Red Hat Enterprise Linux）通常会自带screen实用程序，如果没有的话，可以从GNU screen的官方网站下载。
                  &lt;/p&gt;
                  
                  &lt;div class=&#34;cnblogs_code&#34;&gt;
                    &lt;pre&gt;[root@TS-DEV ~]# yum install screen
[root@TS-DEV ~]# rpm -qa|grep screen
screen-4.0.3-4.el5
[root@TS-DEV ~]#&lt;/pre&gt;
                  &lt;/div&gt;
                  

&lt;pre&gt;&lt;code&gt;              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;5.2 创建一个新的窗口&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                安装完成后，直接敲命令screen就可以启动它。但是这样启动的screen会话没有名字，实践上推荐为每个screen会话取一个名字，方便分辨：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen -S david&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                screen启动后，会创建第一个窗口，也就是窗口No. 0，并在其中打开一个系统默认的shell，一般都会是bash。所以你敲入命令screen之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入Screen的世界了。当然，也可以在screen命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen vi david.txt&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                screen创建一个执行vi david.txt的单窗口会话，退出vi 将退出该窗口/会话。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;5.3 查看窗口和窗口名称&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                打开多个窗口后，可以使用快捷键C-a w列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用X环境下的终端模拟器，这个列表会列在标题栏里。窗口列表的样子一般是这样：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;0$ bash  1-$ bash  2*$ bash&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                这个例子中我开启了三个窗口，其中*号表示当前位于窗口2，-号表示上一次切换窗口时位于窗口1。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                Screen默认会为窗口命名为编号和窗口中运行程序名的组合，上面的例子中窗口都是默认名字。练习了上面查看窗口的方法，你可能就希望各个窗口可以有不同的名字以方便区分了。可以使用快捷键C-a A来为当前窗口重命名，按下快捷键后，Screen会允许你为当前窗口输入新的名字，回车确认。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;5.4 会话分离与恢复&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个screen窗口编辑/tmp/david.txt文件：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen vi /tmp/david.txt&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入&amp;lt;code&amp;gt;C-a d&amp;lt;/code&amp;gt;，Screen会给出detached提示：
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;暂时中断会话&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;img src=&amp;quot;http://images.cnitblog.com/blog/370046/201301/29144351-ff7e78c079a44f51ae44d48b6942b87f.jpg&amp;quot; alt=&amp;quot;&amp;quot; width=&amp;quot;900&amp;quot; /&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                半个小时之后回来了，找到该screen会话：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen -ls&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;img src=&amp;quot;http://images.cnitblog.com/blog/370046/201301/29144759-7cea9fc3f5f4481ab21df8bd017c88ef.jpg&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                重新连接会话：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen -r 12865&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                一切都在。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                当然，如果你在另一台机器上没有分离一个Screen会话，就无从恢复会话了。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来：
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;img src=&amp;quot;http://images.cnitblog.com/blog/370046/201301/29215655-6d2f0c7e7f294756a4b40a40e1e76a84.jpg&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;5.5 清除dead 会话&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话：
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;img src=&amp;quot;http://images.cnitblog.com/blog/370046/201301/29154746-51185199905542c68d3c3b46dddef648.jpg&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;5.6 关闭或杀死窗口&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                正常情况下，当你退出一个窗口中最后一个程序（通常是bash）后，这个窗口就关闭了。另一个关闭窗口的方法是使用C-a k，这个快捷键杀死当前的窗口，同时也将杀死这个窗口中正在运行的进程。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                如果一个Screen会话中最后一个窗口被关闭了，那么整个Screen会话也就退出了，screen进程会被终止。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                除了依次退出/杀死当前Screen会话中所有窗口这种方法之外，还可以使用快捷键C-a :，然后输入quit命令退出Screen会话。需要注意的是，这样退出会杀死所有窗口并退出其中运行的所有程序。其实C-a :这个快捷键允许用户直接输入的命令有很多，包括分屏可以输入split等，这也是实现Screen功能的一个途径，不过个人认为还是快捷键比较方便些。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;六、screen 高级应用 &amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;6.1 会话共享&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                还有一种比较好玩的会话恢复，可以实现会话共享。假设你在和朋友在不同地点以相同用户登录一台机器，然后你创建一个screen会话，你朋友可以在他的终端上命令：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen -x&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                这个命令会将你朋友的终端Attach到你的Screen会话上，并且你的终端不会被Detach。这样你就可以和朋友共享同一个会话了，如果你们当前又处于同一个窗口，那就相当于坐在同一个显示器前面，你的操作会同步演示给你朋友，你朋友的操作也会同步演示给你。当然，如果你们切换到这个会话的不同窗口中去，那还是可以分别进行不同的操作的。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;6.2 会话锁定与解锁&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                Screen允许使用快捷键C-a s锁定会话。锁定以后，再进行任何输入屏幕都不会再有反应了。但是要注意虽然屏幕上看不到反应，但你的输入都会被Screen中的进程接收到。快捷键C-a q可以解锁一个会话。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                也可以使用C-a x锁定会话，不同的是这样锁定之后，会话会被Screen所属用户的密码保护，需要输入密码才能继续访问这个会话。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;6.3 发送命令到screen会话&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                在Screen会话之外，可以通过screen命令操作一个Screen会话，这也为使用Screen作为脚本程序增加了便利。关于Screen在脚本中的应用超出了入门的范围，这里只看一个例子，体会一下在会话之外对Screen的操作：
              &amp;lt;/p&amp;gt;

              &amp;lt;div class=&amp;quot;cnblogs_code&amp;quot;&amp;gt;
                &amp;lt;pre&amp;gt;[root@TS-DEV ~]# screen -S sandy -X screen ping www.baidu.com&amp;lt;/pre&amp;gt;
              &amp;lt;/div&amp;gt;

              &amp;lt;p&amp;gt;
                这个命令在一个叫做sandy的screen会话中创建一个新窗口，并在其中运行ping命令。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;6.4 屏幕分割&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                现在显示器那么大，将一个屏幕分割成不同区域显示不同的Screen窗口显然是个很酷的事情。可以使用快捷键C-a S将显示器水平分割，Screen 4.00.03版本以后，也支持垂直分屏，快捷键是C-a |。分屏以后，可以使用C-a &amp;lt;tab&amp;gt;在各个区块间切换，每一区块上都可以创建窗口并在其中运行进程。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                可以用C-a X快捷键关闭当前焦点所在的屏幕区块，也可以用C-a Q关闭除当前区块之外其他的所有区块。关闭的区块中的窗口并不会关闭，还可以通过窗口切换找到它。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;img src=&amp;quot;http://images.cnitblog.com/blog/370046/201301/29205553-38cdde403beb45f4814ca9a180987a9e.jpg&amp;quot; alt=&amp;quot;&amp;quot; width=&amp;quot;900&amp;quot; /&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;6.5 C/P模式和操作&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                screen的另一个很强大的功能就是可以在不同窗口之间进行复制粘贴了。使用快捷键C-a &amp;lt;Esc&amp;gt;或者C-a [可以进入copy/paste模式，这个模式下可以像在vi中一样移动光标，并可以使用空格键设置标记。其实在这个模式下有很多类似vi的操作，譬如使用/进行搜索，使用y快速标记一行，使用w快速标记一个单词等。关于C/P模式下的高级操作，其文档的这一部分有比较详细的说明。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                一般情况下，可以移动光标到指定位置，按下空格设置一个开头标记，然后移动光标到结尾位置，按下空格设置第二个标记，同时会将两个标记之间的部分储存在copy/paste buffer中，并退出copy/paste模式。在正常模式下，可以使用快捷键C-a ]将储存在buffer中的内容粘贴到当前窗口。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;img src=&amp;quot;http://images.cnitblog.com/blog/370046/201301/29210355-9026652834d446d2bbafa18fd7bca276.jpg&amp;quot; alt=&amp;quot;&amp;quot; width=&amp;quot;900&amp;quot; /&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                &amp;lt;strong&amp;gt;6.6 更多screen功能&amp;lt;/strong&amp;gt;
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                同大多数UNIX程序一样，GNU Screen提供了丰富强大的定制功能。你可以在Screen的默认两级配置文件/etc/screenrc和$HOME/.screenrc中指定更多，例如设定screen选项，定制绑定键，设定screen会话自启动窗口，启用多用户模式，定制用户访问权限控制等等。如果你愿意的话，也可以自己指定screen配置文件。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                以多用户功能为例，screen默认是以单用户模式运行的，你需要在配置文件中指定multiuser on 来打开多用户模式，通过acl*（acladd,acldel,aclchg&amp;amp;#8230;）命令，你可以灵活配置其他用户访问你的screen会话。更多配置文件内容请参考screen的man页。
              &amp;lt;/p&amp;gt;

              &amp;lt;p&amp;gt;
                原文链接:&amp;lt;a href=&amp;quot;http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html&amp;lt;/a&amp;gt;
              &amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>非root用户使用tcpdump</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/23/tcpdumpnoroot.html</link>
      <pubDate>Sun, 23 Aug 2015 15:10:26 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/23/tcpdumpnoroot.html</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt; centos/redhat下安装tcpdump &lt;pre class=&#34;lang:default decode:true&#34;&gt;sudo yum install -y tcpdump&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 在tcpdump所在目录下执行 &lt;pre class=&#34;lang:sh decode:true&#34;&gt;sudo chmod u+s tcpdump&lt;/pre&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;nbsp;&lt;/li&gt; &lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;原理参考： &lt;em&gt;&lt;a href=&#34;http://blog.csdn.net/arkblue/article/details/7704304&#34;&gt;tcpdump 安装和文件的s权限 &amp;#8211; arkblue的专栏 &amp;#8211; 博客频道 &amp;#8211; CSDN.NET&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Linux 命令行参数处理函数探究(转)</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/23/linux-getopt.html</link>
      <pubDate>Sun, 23 Aug 2015 01:59:32 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/23/linux-getopt.html</guid>
      <description>&lt;p&gt;一、getopt函数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526381qRMV.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;div&gt;
  A.函数功能：处理命令行参数
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  B.参数:
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  argc代表命令行参数的个数，argv[i]存放命令行参数在内存存放的地址。这两个参数直接从mian(int argc,char *argv[])得到。
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  如果argv的元素是以 &amp;#8220;-“开头称为一个选项元素,紧跟在&amp;#8221;-&amp;#8220;后面的一个字符称为选项字符。
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  eg:ls  -l
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  其中ls是可执行程序名称，-l称为选项元素，&amp;#8217;l&amp;#8217;称为选项字符
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  optstring:选项参数的集合
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  注意:如果getopt()函数被循环调用，每次调用都会返回一个对应选元素的选项字符,如果所有选项字符都放回后，再次调用getopt()函数返回-1。
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;pre class=&#34;lang:c decode:true &#34;&gt;./a.out   -a  -n  -l
 
while(1)
{
    ch = getopt(argc,argv,&#34;anl&#34;);
}&lt;/pre&gt;
  
  &lt;p&gt;
    &amp;nbsp;
  &lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
  第一次调用ch : &amp;#8216;a&amp;#8217;
&lt;/div&gt;

&lt;div&gt;
  第二次调用ch : &amp;#8216;n&amp;#8217;
&lt;/div&gt;

&lt;div&gt;
  第三次调用ch : &amp;#8216;l&amp;#8217;
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;p&gt;
    案例一、
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a class=&#34;evt&#34; href=&#34;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526418yiyG.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;o=1&amp;et=normal&amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;f=1f4be180-7e44-4e3f-9802-b2e7872c9dc2&amp;n=26833883_1337526418yiyG.png&amp;ext=png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;evt&#34; href=&#34;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526453JOOB.png&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;o=1&amp;et=normal&amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;f=c9a8f641-7970-457e-8640-76c5eef14900&amp;n=26833883_1337526453JOOB.png&amp;ext=png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div&gt;
  C.变量optind
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  每次getopt函数调用的时候，optind总是当前处理argv[index]的下一个被处理选项元素的索引即optind = index + 1，如:当前处理的选项元素argv[1]，则optind的值为2,即argv[2]的索引。
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  注意：其值默认初始化为1,如果。
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;p&gt;
    案例二、
  &lt;/p&gt;
  
  &lt;div&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;pre class=&#34;lang:c decode:true &#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int main(int argc,char *argv[])
{
    int ch;
    while((ch = getopt(argc,argv,&#34;cyg&#34;)) != -1)
    {
        switch(ch)
        {
        case &#39;c&#39;:
            printf(&#34;optind = %d\n&#34;,optind);
            printf(&#34;Option character \&#39;c\&#39;.\n&#34;);
            break;
        case &#39;y&#39;:
            printf(&#34;optind = %d\n&#34;,optind);
            printf(&#34;Option character \&#39;y\&#39;.\n&#34;);
            break;
        case &#39;g&#39;:
            printf(&#34;optind = %d\n&#34;,optind);
            printf(&#34;Option character \&#39;g\&#39;.\n&#34;);
            break;
        }
    }
    printf(&#34;Ending...\n&#34;);
    printf(&#34;optind = %d\n&#34;,optind);
    return 0;
}&lt;/pre&gt;
        
        &lt;p&gt;
          &amp;nbsp;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; 
          

&lt;pre&gt;&lt;code&gt;      &amp;lt;p&amp;gt;
        运行结果:
      &amp;lt;/p&amp;gt;

      &amp;lt;p&amp;gt;
        &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526516f9w5.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=e78c330d-84fb-4f42-9e4f-5799ac7a0a7d&amp;amp;n=26833883_1337526516f9w5.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
      &amp;lt;/p&amp;gt;

      &amp;lt;div&amp;gt;
        D.变量optarg
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
        如果optstring选项字符后面紧跟一个&amp;amp;#8221;:&amp;amp;#8221;，则要求选项元素后面跟一个参数;
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
        如果optstring选项字符后面紧跟两个&amp;amp;#8221;::&amp;amp;#8221;，则选项元素后面可以跟一个可选的参数
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;
          案例三:
        &amp;lt;/p&amp;gt;

        &amp;lt;div&amp;gt;
          &amp;lt;ol&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;pre class=&amp;quot;lang:c decode:true &amp;quot;&amp;gt;#include &amp;amp;lt;stdio.h&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#include &amp;lt;unistd.h&amp;gt;
int main(int argc,char *argv[])
{
    int ch;
    while((ch = getopt(argc,argv,&amp;laquo;c:yg::&amp;laquo;)) != -1)
    {
        switch(ch)
        {
        case &amp;lsquo;c&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;optarg = %s\n&amp;raquo;,optarg);
            printf(&amp;laquo;Option character \&amp;lsquo;c\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;y&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;Option character \&amp;lsquo;y\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;g&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;optarg = %s\n&amp;raquo;,optarg);
            printf(&amp;laquo;Option character \&amp;lsquo;g\&amp;lsquo;.\n&amp;raquo;);
            break;
        }
    }
    printf(&amp;laquo;Ending&amp;hellip;\n&amp;raquo;);
    printf(&amp;laquo;argv[%d] = %s\n&amp;raquo;,optind,argv[optind]);
    return 0;
}&lt;/pre&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              &amp;lt;p&amp;gt;
                &amp;amp;nbsp;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; 

                &amp;lt;p&amp;gt;
                  &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526570jxAE.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=476757e3-8aa2-4d6b-b9f1-7c40b78d1225&amp;amp;n=26833883_1337526570jxAE.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                &amp;lt;/p&amp;gt;

                &amp;lt;div&amp;gt;
                  注意：上面的最后一次运行结果，&amp;amp;#8221;xxx&amp;amp;#8221;在一开始在argv的的索引值为3,但是我们发现它实际的索引值是4。这是因为getopt函数，会把不拥有选项参数的选项字符后面的操作数，放在最后。
                &amp;lt;/div&amp;gt;

                &amp;lt;div&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;div&amp;gt;
                  E.变量opterr和变量optopt
                &amp;lt;/div&amp;gt;

                &amp;lt;div&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;div&amp;gt;
                  getopt()函数在搜索argv时，如果发现argv拥有optstring所没有的选项字符，则会提示立即返回&amp;amp;#8217;?&amp;amp;#8217;,并提示错误信息，所没有的选项字符会放在opt里。如果不想系统提示默认的错误信息，将opterr设为0即可。
                &amp;lt;/div&amp;gt;

                &amp;lt;div&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;div&amp;gt;
                  &amp;lt;p&amp;gt;
                    案例四:
                  &amp;lt;/p&amp;gt;

                  &amp;lt;div&amp;gt;
                    &amp;lt;ol&amp;gt;
                      &amp;lt;li&amp;gt;
                        &amp;lt;pre class=&amp;quot;lang:c decode:true &amp;quot;&amp;gt;#include &amp;amp;lt;stdio.h&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#include &amp;lt;unistd.h&amp;gt;
int main(int argc,char *argv[])
{
    int ch;
    while((ch = getopt(argc,argv,&amp;laquo;c:yg::&amp;laquo;)) != -1)
    {
        switch(ch)
        {
        case &amp;lsquo;c&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;optarg = %s\n&amp;raquo;,optarg);
            printf(&amp;laquo;Option character \&amp;lsquo;c\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;y&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;Option character \&amp;lsquo;y\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;g&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;optarg = %s\n&amp;raquo;,optarg);
            printf(&amp;laquo;Option character \&amp;lsquo;g\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;?&amp;rsquo;:
            printf(&amp;laquo;Invalid Option character \&amp;lsquo;%c\&amp;lsquo;.\n&amp;raquo;,optopt);
            break;
        }
    }
    printf(&amp;laquo;Ending&amp;hellip;\n&amp;raquo;);
    printf(&amp;laquo;argv[%d] = %s\n&amp;raquo;,optind,argv[optind]);
    return 0;
}&lt;/pre&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                        &amp;lt;p&amp;gt;
                          &amp;amp;nbsp;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; 

                          &amp;lt;p&amp;gt;
                            运行结果：
                          &amp;lt;/p&amp;gt;

                          &amp;lt;p&amp;gt;
                            &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526663lAlS.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=969fecda-458d-419b-b5b6-418ea7b2f6c9&amp;amp;n=26833883_1337526663lAlS.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                          &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; 

                          &amp;lt;div&amp;gt;
                            注意:如果optstring字符串一开始就是&amp;amp;#8221;:&amp;amp;#8221;，则后面要求有选项参数的选项字符，在argv中没有选项参数时，此时调用getopt函数返回&amp;amp;#8221;:&amp;amp;#8221;,optopt存放的是没有跟选项参数的选项字符。
                          &amp;lt;/div&amp;gt;

                          &amp;lt;div&amp;gt;
                          &amp;lt;/div&amp;gt;

                          &amp;lt;div&amp;gt;
                            &amp;lt;p&amp;gt;
                              案例五:
                            &amp;lt;/p&amp;gt;

                            &amp;lt;div&amp;gt;
                              &amp;lt;ol&amp;gt;
                                &amp;lt;li&amp;gt;
                                  &amp;lt;pre class=&amp;quot;lang:c decode:true &amp;quot;&amp;gt;#include &amp;amp;lt;stdio.h&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#include &amp;lt;unistd.h&amp;gt;
int main(int argc,char *argv[])
{
    int ch;
    while((ch = getopt(argc,argv,&amp;raquo;:c:yg::&amp;laquo;)) != -1)
    {
        switch(ch)
        {
        case &amp;lsquo;c&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;optarg = %s\n&amp;raquo;,optarg);
            printf(&amp;laquo;Option character \&amp;lsquo;c\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;y&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;Option character \&amp;lsquo;y\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;g&amp;rsquo;:
            printf(&amp;laquo;optarg = %s\n&amp;raquo;,optarg);
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;Option character \&amp;lsquo;g\&amp;lsquo;.\n&amp;raquo;);
            break;
        case &amp;lsquo;:&amp;rsquo;:
            printf(&amp;laquo;Option character \&amp;lsquo;%c\&amp;lsquo;,forget argument.\n&amp;raquo;,optopt);
            break;
        case &amp;lsquo;?&amp;rsquo;:
            printf(&amp;laquo;optind = %d\n&amp;raquo;,optind);
            printf(&amp;laquo;Invalid Option character \&amp;lsquo;%c\&amp;lsquo;.\n&amp;raquo;,optopt);
            break;
        }
    }
    printf(&amp;laquo;Ending&amp;hellip;\n&amp;raquo;);
    printf(&amp;laquo;argv[%d] = %s\n&amp;raquo;,optind,argv[optind]);
    return 0;
}&lt;/pre&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                  &amp;lt;p&amp;gt;
                                    &amp;amp;nbsp;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; 

                                    &amp;lt;p&amp;gt;
                                      运行结果:
                                    &amp;lt;/p&amp;gt;

                                    &amp;lt;p&amp;gt;
                                      &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526728MXSY.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=1ea510f3-b09d-4baf-a471-6ef043040479&amp;amp;n=26833883_1337526728MXSY.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                                    &amp;lt;/p&amp;gt;

                                    &amp;lt;div&amp;gt;
                                      二、getopt_long函数
                                    &amp;lt;/div&amp;gt;

                                    &amp;lt;div&amp;gt;
                                    &amp;lt;/div&amp;gt;

                                    &amp;lt;div&amp;gt;
                                       getopt_long函数也是处理命令行参数,我们会发现它多了一个long,这个long的意思是它支持长选项。
                                    &amp;lt;/div&amp;gt;

                                    &amp;lt;div&amp;gt;
                                      前面我们讨论都是含有一个&amp;amp;#8221;-&amp;amp;#8220;的选项，常我们会看到&amp;amp;#8221;&amp;amp;#8211;help&amp;amp;#8221;这样的造型，其实这就是命令行参数中的长选项。一般短选项是选项名的缩写,长选项是选项名的全名。&amp;lt;br /&amp;gt; &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526761a12B.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=0250a467-60da-482d-8a3a-8c8d40b85c22&amp;amp;n=26833883_1337526761a12B.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526779136u.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=9ee72e9f-4d2b-4f82-9568-6c97ed9d5f9b&amp;amp;n=26833883_1337526779136u.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt; 

                                      &amp;lt;div&amp;gt;
                                        这个函数前三个参数和getopt一样，不解释了。我们来看看后面两个参数。
                                      &amp;lt;/div&amp;gt;

                                      &amp;lt;div&amp;gt;
                                        getopt_long的长选项是一个结构体，定义如下:
                                      &amp;lt;/div&amp;gt;

                                      &amp;lt;p&amp;gt;
                                        &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526826Y0Ny.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=4788c644-deda-402c-9d54-c8b50537979d&amp;amp;n=26833883_1337526826Y0Ny.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526848iHkr.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=bddbf760-90e4-4313-b9c4-f8749ad19fbe&amp;amp;n=26833883_1337526848iHkr.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                                      &amp;lt;/p&amp;gt;

                                      &amp;lt;div&amp;gt;
                                        参数longindex不为空时，存放的是getopt_long处理当前长选项的索引值。
                                      &amp;lt;/div&amp;gt;

                                      &amp;lt;div&amp;gt;
                                      &amp;lt;/div&amp;gt;

                                      &amp;lt;div&amp;gt;
                                        &amp;lt;p&amp;gt;
                                          案例六:
                                        &amp;lt;/p&amp;gt;

                                        &amp;lt;div&amp;gt;
                                          &amp;lt;ol&amp;gt;
                                            &amp;lt;li&amp;gt;
                                              &amp;lt;pre class=&amp;quot;lang:c decode:true &amp;quot;&amp;gt;#include &amp;amp;lt;stdio.h&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;getopt.h&amp;gt;
int main(int argc,char *argv[])
{
    int flag_value = 100;
    while(1)
    {
        int option_index = 0;
        int rvalue = 0;
        static struct option long_option[] = {
            {&amp;laquo;help0&amp;raquo;,no_argument,0,0},
            {&amp;laquo;help1&amp;raquo;,required_argument,0,0},
            {&amp;laquo;help2&amp;raquo;,optional_argument,0,0},
            {&amp;laquo;help3&amp;raquo;,no_argument,0,10},
            {0,0,0,0},
        };
        long_option[3].flag = &amp;amp;flag_value;
        rvalue = getopt_long(argc,argv,&amp;laquo;a:bc::&amp;laquo;,long_option,&amp;amp;option_index);
        if(rvalue == -1)
        {
            printf(&amp;laquo;No more argument.\n&amp;raquo;);
            return -1;
        }
        switch(option_index)
        {
        case 0:
            printf(&amp;laquo;Long option is : %s\n&amp;raquo;,long_option[option_index].name);
            break;
        case 1:
            printf(&amp;laquo;Long option is : %s &amp;laquo;,long_option[option_index].name);
            if(optarg)
            {
                printf(&amp;laquo;with parm &amp;lsquo;%s&amp;rsquo;&amp;raquo;,optarg);
            }
            printf(&amp;raquo;\n&amp;raquo;);
            break;
        case 2:
            printf(&amp;laquo;Long option is : %s &amp;laquo;,long_option[option_index].name);
            if(optarg)
            {
                printf(&amp;laquo;with parm &amp;lsquo;%s&amp;rsquo;&amp;raquo;,optarg);
            }
            printf(&amp;raquo;\n&amp;raquo;);
            break;
        case 3:
            printf(&amp;laquo;Long option is : %s\n&amp;raquo;,long_option[option_index].name);
            break;
        }
        printf(&amp;laquo;flag_value = %d\n&amp;raquo;,flag_value);
    }
    return 0;
}&lt;/pre&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                              &amp;lt;p&amp;gt;
                                                &amp;amp;nbsp;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; 

                                                &amp;lt;p&amp;gt;
                                                  运行结果：
                                                &amp;lt;/p&amp;gt;

                                                &amp;lt;p&amp;gt;
                                                  &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526922IiY2.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=eeed00f5-f0fe-4441-8cae-196af0abe73d&amp;amp;n=26833883_1337526922IiY2.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                                                &amp;lt;/p&amp;gt;

                                                &amp;lt;p&amp;gt;
                                                  三、getopt_long_only函数
                                                &amp;lt;/p&amp;gt;

                                                &amp;lt;p&amp;gt;
                                                  &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_13375269502qqp.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=aa5692ae-dfa9-4ffb-9feb-d74c50616a73&amp;amp;n=26833883_13375269502qqp.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337526976l7vv.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=577129ce-6c34-4f6b-b3b9-e960116757f5&amp;amp;n=26833883_1337526976l7vv.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                                                &amp;lt;/p&amp;gt;

                                                &amp;lt;p&amp;gt;
                                                  案例:
                                                &amp;lt;/p&amp;gt;

                                                &amp;lt;div&amp;gt;
                                                  &amp;lt;ol&amp;gt;
                                                    &amp;lt;li&amp;gt;
                                                      &amp;lt;pre class=&amp;quot;lang:c decode:true&amp;quot;&amp;gt;#include &amp;amp;lt;stdio.h&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;getopt.h&amp;gt;
int main(int argc,char *argv[])
{
    int flag_value = 100;
    while(1)
    {
        int option_index = 0;
        int rvalue = 0;
        static struct option long_option[] = {
            {&amp;laquo;help0&amp;raquo;,no_argument,0,0},
            {&amp;laquo;help1&amp;raquo;,required_argument,0,0},
            {&amp;laquo;help2&amp;raquo;,optional_argument,0,0},
            {&amp;laquo;help3&amp;raquo;,no_argument,0,10},
            {0,0,0,0},
        };
        long_option[3].flag = &amp;amp;flag_value;
        rvalue = getopt_long_only(argc,argv,&amp;laquo;a:bc::&amp;laquo;,long_option,&amp;amp;option_index);
        if(rvalue == -1)
        {
            printf(&amp;laquo;No more argument.\n&amp;raquo;);
            return -1;
        }
        switch(option_index)
        {
        case 0:
            printf(&amp;laquo;Long option is : %s\n&amp;raquo;,long_option[option_index].name);
            break;
        case 1:
            printf(&amp;laquo;Long option is : %s &amp;laquo;,long_option[option_index].name);
            if(optarg)
            {
                printf(&amp;laquo;with parm &amp;lsquo;%s&amp;rsquo;&amp;raquo;,optarg);
            }
            printf(&amp;raquo;\n&amp;raquo;);
            break;
        case 2:
            printf(&amp;laquo;Long option is : %s &amp;laquo;,long_option[option_index].name);
            if(optarg)
            {
                printf(&amp;laquo;with parm &amp;lsquo;%s&amp;rsquo;&amp;raquo;,optarg);
            }
            printf(&amp;raquo;\n&amp;raquo;);
            break;
        case 3:
            printf(&amp;laquo;Long option is : %s\n&amp;raquo;,long_option[option_index].name);
            break;
        }
        printf(&amp;laquo;flag_value = %d\n&amp;raquo;,flag_value);
    }
    return 0;
}&lt;/pre&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                                      &amp;lt;p&amp;gt;
                                                        &amp;amp;nbsp;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; 

                                                        &amp;lt;p&amp;gt;
                                                          运行结果：
                                                        &amp;lt;/p&amp;gt;

                                                        &amp;lt;p&amp;gt;
                                                          &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337527059HQkS.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=779d825e-bea2-4de1-9563-d18e6671053b&amp;amp;n=26833883_1337527059HQkS.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                                                        &amp;lt;/p&amp;gt;

                                                        &amp;lt;p&amp;gt;
                                                          注意：getopt_long和getopt_long_only的返回值
                                                        &amp;lt;/p&amp;gt;

                                                        &amp;lt;p&amp;gt;
                                                          &amp;lt;a class=&amp;quot;evt&amp;quot; href=&amp;quot;http://blog.chinaunix.net/attachment/201205/20/26833883_1337527087i1XX.png&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://mail.gsymy.com/attachment/downloadex?e=wordpress%40gsymy.com&amp;amp;o=1&amp;amp;et=normal&amp;amp;m=2_0%3ADzzzzye7hPs%24----3XZGQex&amp;amp;f=19c38a3c-d577-4086-8152-542a97093e78&amp;amp;n=26833883_1337527087i1XX.png&amp;amp;ext=png&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;
                                                        &amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 

                                                        &amp;lt;p&amp;gt;
                                                          原文链接:&amp;lt;a href=&amp;quot;http://blog.chinaunix.net/uid-26833883-id-3215592.html#&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;http://blog.chinaunix.net/uid-26833883-id-3215592.html#&amp;lt;/a&amp;gt;
                                                        &amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>怎么编写Linux守护程序</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/18/linux-daemon-writing-howto.html</link>
      <pubDate>Tue, 18 Aug 2015 02:26:13 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/18/linux-daemon-writing-howto.html</guid>
      <description>

&lt;p&gt;来源： &lt;em&gt;&lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#&#34;&gt;Linux Daemon Writing HOWTO&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;linux-daemon-writing-howto&#34;&gt;Linux Daemon Writing HOWTO&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;this-document-shows-how-to-write-a-daemon-in-linux-using-gcc-knowledge-of-linux-and-a-familiarity-with-c-are-necessary-to-use-this-document-this-howto-is-copyright-by-devin-watson-under-the-terms-of-the-bsd-license&#34;&gt;&lt;em&gt;This document shows how to write a daemon in Linux using GCC. Knowledge of Linux and a familiarity with C are necessary to use this document. This HOWTO is Copyright by Devin Watson, under the terms of the BSD License.&lt;/em&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;a-name-toc1-a-1-introduction-what-is-a-daemon-2&#34;&gt;&lt;a name=&#34;toc1&#34;&gt;&lt;/a&gt;1. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#s1&#34;&gt;Introduction: What is a Daemon?&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;a-name-toc2-a-2-getting-started-3&#34;&gt;&lt;a name=&#34;toc2&#34;&gt;&lt;/a&gt;2. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#s2&#34;&gt;Getting Started&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;a-name-toc3-a-3-planning-your-daemon-4&#34;&gt;&lt;a name=&#34;toc3&#34;&gt;&lt;/a&gt;3. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#s3&#34;&gt;Planning Your Daemon&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a name=&#34;toc3.1&#34;&gt;&lt;/a&gt;3.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss3.1&#34;&gt;What Is It Going To Do?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc3.2&#34;&gt;&lt;/a&gt;3.2 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss3.2&#34;&gt;How Much Interaction?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-toc4-a-4-basic-daemon-structure-7&#34;&gt;&lt;a name=&#34;toc4&#34;&gt;&lt;/a&gt;4. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#s4&#34;&gt;Basic Daemon Structure&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a name=&#34;toc4.1&#34;&gt;&lt;/a&gt;4.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss4.1&#34;&gt;Forking The Parent Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc4.2&#34;&gt;&lt;/a&gt;4.2 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss4.2&#34;&gt;Changing The File Mode Mask (Umask)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc4.3&#34;&gt;&lt;/a&gt;4.3 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss4.3&#34;&gt;Opening Logs For Writing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc4.4&#34;&gt;&lt;/a&gt;4.4 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss4.4&#34;&gt;Creating a Unique Session ID (SID)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc4.5&#34;&gt;&lt;/a&gt;4.5 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss4.5&#34;&gt;Changing The Working Directory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc4.6&#34;&gt;&lt;/a&gt;4.6 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss4.6&#34;&gt;Closing Standard File Descriptors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-toc5-a-5-writing-the-daemon-code-14&#34;&gt;&lt;a name=&#34;toc5&#34;&gt;&lt;/a&gt;5. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#s5&#34;&gt;Writing the Daemon Code&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a name=&#34;toc5.1&#34;&gt;&lt;/a&gt;5.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss5.1&#34;&gt;Initialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a name=&#34;toc5.2&#34;&gt;&lt;/a&gt;5.2 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss5.2&#34;&gt;The Big Loop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-toc6-a-6-putting-it-all-together-17&#34;&gt;&lt;a name=&#34;toc6&#34;&gt;&lt;/a&gt;6. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#s6&#34;&gt;Putting It All Together&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a name=&#34;toc6.1&#34;&gt;&lt;/a&gt;6.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#ss6.1&#34;&gt;Complete Sample&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;a-name-s1-a-1-introduction-what-is-a-daemon-19&#34;&gt;&lt;a name=&#34;s1&#34;&gt;&lt;/a&gt;1. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc1&#34;&gt;Introduction: What is a Daemon?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A daemon (or service) is a background process that is designed to run autonomously,with little or not user intervention. The Apache web server http daemon (httpd) is one such example of a daemon. It waits in the background listening on specific ports, and serves up pages or processes scripts, based on the type of request.&lt;/p&gt;

&lt;p&gt;Creating a daemon in Linux uses a specific set of rules in a given order. Knowing how they work will help you understand how daemons operate in userland Linux, but can operate with calls to the kernel also. In fact, a few daemons interface with kernel modules that work with hardware devices, such as external controller boards, printers,and PDAs. They are one of the fundamental building blocks in Linux that give it incredible flexibility and power.&lt;/p&gt;

&lt;p&gt;Throughout this HOWTO, a very simple daemon will be built in C. As we go along, more code will be added, showing the proper order of execution required to get a daemon up and running.&lt;/p&gt;

&lt;h2 id=&#34;a-name-s2-a-2-getting-started-20&#34;&gt;&lt;a name=&#34;s2&#34;&gt;&lt;/a&gt;2. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc2&#34;&gt;Getting Started&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;First off, you&amp;#8217;ll need the following packages installed on your Linux machine to develop daemons, specifically:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GCC 3.2.2 or higher&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Linux Development headers and libraries&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If your system does not already have these installed (not likely, but check anyway), you&amp;#8217;ll need them to develop the examples in this HOWTO. To find out what version of GCC you have installed, use:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;gcc --version
&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-name-s3-a-3-planning-your-daemon-21&#34;&gt;&lt;a name=&#34;s3&#34;&gt;&lt;/a&gt;3. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc3&#34;&gt;Planning Your Daemon&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;a-name-ss3-1-a-3-1-what-is-it-going-to-do-22&#34;&gt;&lt;a name=&#34;ss3.1&#34;&gt;&lt;/a&gt;3.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc3.1&#34;&gt;What Is It Going To Do?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A daemon should do one thing, and do it well. That one thing may be as complex as managing hundreds of mailboxes on multiple domains, or as simple as writing a report and calling sendmail to mail it out to an admin.&lt;/p&gt;

&lt;p&gt;In any case, you should have a good plan going in what the daemon should do. If it is going to interoperate with some other daemons that you may or may not be writing, this is something else to consider as well.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss3-2-a-3-2-how-much-interaction-23&#34;&gt;&lt;a name=&#34;ss3.2&#34;&gt;&lt;/a&gt;3.2 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc3.2&#34;&gt;How Much Interaction?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Daemons should never have direct communication with a user through a terminal. In fact, a daemon shouldn&amp;#8217;t communicate directly with a user at all. All communication should pass through some sort of interface (which you may or may not have to write), which can be as complex as a GTK+ GUI, or as simple as a signal set.&lt;/p&gt;

&lt;h2 id=&#34;a-name-s4-a-4-basic-daemon-structure-24&#34;&gt;&lt;a name=&#34;s4&#34;&gt;&lt;/a&gt;4. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4&#34;&gt;Basic Daemon Structure&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;When a daemon starts up, it has to do some low-level housework to get itself ready for its real job. This involves a few steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fork off the parent process&lt;/li&gt;
&lt;li&gt;Change file mode mask (umask)&lt;/li&gt;
&lt;li&gt;Open any logs for writing&lt;/li&gt;
&lt;li&gt;Create a unique Session ID (SID)&lt;/li&gt;
&lt;li&gt;Change the current working directory to a safe place&lt;/li&gt;
&lt;li&gt;Close standard file descriptors&lt;/li&gt;
&lt;li&gt;Enter actual daemon code&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-name-ss4-1-a-4-1-forking-the-parent-process-25&#34;&gt;&lt;a name=&#34;ss4.1&#34;&gt;&lt;/a&gt;4.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4.1&#34;&gt;Forking The Parent Process&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A daemon is started either by the system itself or a user in a terminal or script. When it does start, the process is just like any other executable on the system. To make it truly autonomous, a &lt;em&gt;child process&lt;/em&gt; must be created where the actual code is executed. This is known as forking, and it uses the &lt;em&gt;fork()&lt;/em&gt; function:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;pid_t pid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    /* Fork off the parent process */       
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Notice the error check right after the call to &lt;em&gt;fork()&lt;/em&gt;. When writing a daemon, you will have to code as defensively as possible. In fact, a good percentage of the total code in a daemon consists of nothing but error checking.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;fork()&lt;/em&gt; function returns either the process id (PID) of the child process (not equal to zero), or -1 on failure. If the process cannot fork a child, then the daemon should terminate right here.&lt;/p&gt;

&lt;p&gt;If the PID returned from &lt;em&gt;fork()&lt;/em&gt; did succeed, the parent process must exit gracefully. This may seem strange to anyone who hasn&amp;#8217;t seen it, but by forking, the child process continues the execution from here on out in the code.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss4-2-a-4-2-changing-the-file-mode-mask-umask-26&#34;&gt;&lt;a name=&#34;ss4.2&#34;&gt;&lt;/a&gt;4.2 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4.2&#34;&gt;Changing The File Mode Mask (Umask)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;In order to write to any files (including logs) created by the daemon, the file mode mask (umask) must be changed to ensure that they can be written to or read from properly. This is similar to running umask from the command line, but we do it programmatically here. We can use the &lt;em&gt;umask()&lt;/em&gt; function to accomplish this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;pid_t pid, sid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    /* Fork off the parent process */
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            /* Log failure (use syslog if possible) */
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;By setting the umask to 0, we will have full access to the files generated by the daemon. Even if you aren&amp;#8217;t planning on using any files, it is a good idea to set the umask here anyway, just in case you will be accessing files on the filesystem.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss4-3-a-4-3-opening-logs-for-writing-27&#34;&gt;&lt;a name=&#34;ss4.3&#34;&gt;&lt;/a&gt;4.3 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4.3&#34;&gt;Opening Logs For Writing&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This part is optional, but it is recommended that you open a log file somewhere in the system for writing. This may be the only place you can look for debug information about your daemon.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss4-4-a-4-4-creating-a-unique-session-id-sid-28&#34;&gt;&lt;a name=&#34;ss4.4&#34;&gt;&lt;/a&gt;4.4 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4.4&#34;&gt;Creating a Unique Session ID (SID)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;From here, the child process must get a unique SID from the kernel in order to operate. Otherwise, the child process becomes an orphan in the system. The pid_t type, declared in the previous section, is also used to create a new SID for the child process:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;pid_t pid, sid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    /* Fork off the parent process */
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);

    /* Open any logs here */

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &amp;amp;lt; 0) {
            /* Log any failure */
            exit(EXIT_FAILURE);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Again, the &lt;em&gt;setsid()&lt;/em&gt; function has the same return type as &lt;em&gt;fork()&lt;/em&gt;. We can apply the same error-checking routine here to see if the function created the SID for the child process.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss4-5-a-4-5-changing-the-working-directory-29&#34;&gt;&lt;a name=&#34;ss4.5&#34;&gt;&lt;/a&gt;4.5 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4.5&#34;&gt;Changing The Working Directory&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The current working directory should be changed to some place that is guaranteed to always be there. Since many Linux distributions do not completely follow the Linux Filesystem Hierarchy standard, the only directory that is guaranteed to be there is the root (/). We can do this using the &lt;em&gt;chdir()&lt;/em&gt; function:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;pid_t pid, sid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    /* Fork off the parent process */
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);       

    /* Open any logs here */        

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &amp;amp;lt; 0) {
            /* Log any failure here */
            exit(EXIT_FAILURE);
    }

    /* Change the current working directory */
    if ((chdir(&amp;quot;/&amp;quot;)) &amp;amp;lt; 0) {
            /* Log any failure here */
            exit(EXIT_FAILURE);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Once again, you can see the defensive coding taking place. The &lt;em&gt;chdir()&lt;/em&gt; function returns -1 on failure, so be sure to check for that after changing to the root directory within the daemon.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss4-6-a-4-6-closing-standard-file-descriptors-30&#34;&gt;&lt;a name=&#34;ss4.6&#34;&gt;&lt;/a&gt;4.6 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc4.6&#34;&gt;Closing Standard File Descriptors&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;One of the last steps in setting up a daemon is closing out the standard file descriptors (STDIN, STDOUT, STDERR). Since a daemon cannot use the terminal, these file descriptors are redundant and a potential security hazard.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;close()&lt;/em&gt; function can handle this for us:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;pid_t pid, sid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    /* Fork off the parent process */
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);       

    /* Open any logs here */

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &amp;amp;lt; 0) {
            /* Log any failure here */
            exit(EXIT_FAILURE);
    }

    /* Change the current working directory */
    if ((chdir(&amp;quot;/&amp;quot;)) &amp;amp;lt; 0) {
            /* Log any failure here */
            exit(EXIT_FAILURE);
    }


    /* Close out the standard file descriptors */
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s a good idea to stick with the constants defined for the file descriptors, for the greatest portability between system versions.&lt;/p&gt;

&lt;h2 id=&#34;a-name-s5-a-5-writing-the-daemon-code-31&#34;&gt;&lt;a name=&#34;s5&#34;&gt;&lt;/a&gt;5. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc5&#34;&gt;Writing the Daemon Code&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;a-name-ss5-1-a-5-1-initialization-32&#34;&gt;&lt;a name=&#34;ss5.1&#34;&gt;&lt;/a&gt;5.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc5.1&#34;&gt;Initialization&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;At this point, you have basically told Linux that you&amp;#8217;re a daemon, so now it&amp;#8217;s time to write the actual daemon code. Initialization is the first step here. Since there can be a multitude of different functions that can be called here to set up your daemon&amp;#8217;s task, I won&amp;#8217;t go too deep into here.&lt;/p&gt;

&lt;p&gt;The big point here is that, when initializing anything in a daemon, the same defensive coding guidelines apply here. Be as verbose as possible when writing either to the syslog or your own logs. Debugging a daemon can be quite difficult when there isn&amp;#8217;t enough information available as to the status of the daemon.&lt;/p&gt;

&lt;h2 id=&#34;a-name-ss5-2-a-5-2-the-big-loop-33&#34;&gt;&lt;a name=&#34;ss5.2&#34;&gt;&lt;/a&gt;5.2 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc5.2&#34;&gt;The Big Loop&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A daemon&amp;#8217;s main code is typically inside of an infinite loop. Technically, it isn&amp;#8217;t an infinite loop, but it is structured as one:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;pid_t pid, sid;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    /* Fork off the parent process */
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);       

    /* Open any logs here */

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &amp;amp;lt; 0) {
            /* Log any failures here */
            exit(EXIT_FAILURE);
    }


    /* Change the current working directory */
    if ((chdir(&amp;quot;/&amp;quot;)) &amp;amp;lt; 0) {
            /* Log any failures here */
            exit(EXIT_FAILURE);
    }

    /* Close out the standard file descriptors */
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    /* Daemon-specific initialization goes here */

    /* The Big Loop */
    while (1) {
       /* Do some task here ... */
       sleep(30); /* wait 30 seconds */
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;This typical loop is usually a &lt;em&gt;while&lt;/em&gt; loop that has an infinite terminating condition, with a call to &lt;em&gt;sleep&lt;/em&gt; in there to make it run at specified intervals.&lt;/p&gt;

&lt;p&gt;Think of it like a heartbeat: when your heart beats, it performs a few tasks, then waits until the next beat takes place. Many daemons follow this same methodology.&lt;/p&gt;

&lt;h2 id=&#34;a-name-s6-a-6-putting-it-all-together-34&#34;&gt;&lt;a name=&#34;s6&#34;&gt;&lt;/a&gt;6. &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc6&#34;&gt;Putting It All Together&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;a-name-ss6-1-a-6-1-complete-sample-35&#34;&gt;&lt;a name=&#34;ss6.1&#34;&gt;&lt;/a&gt;6.1 &lt;a href=&#34;http://www.linuxprofilm.com/articles/linux-daemon-howto.html#toc6.1&#34;&gt;Complete Sample&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Listed below is a complete sample daemon that shows all of the steps necessary for setup and execution. To run this, simply compile using gcc, and start execution from the command line. To terminate, use the &lt;em&gt;kill&lt;/em&gt; command after finding its PID.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ve also put in the correct include statements for interfacing with the syslog, which is recommended at the very least for sending start/stop/pause/die log statements, in addition to using your own logs with the&lt;em&gt;fopen()&lt;/em&gt;/&lt;em&gt;fwrite()&lt;/em&gt;/&lt;em&gt;fclose()&lt;/em&gt; function calls.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;pre&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;syslog.h&amp;gt;
#include &amp;lt;string.h&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;int main(void) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /* Our process ID and Session ID */
    pid_t pid, sid;

    /* Fork off the parent process */
    pid = fork();
    if (pid &amp;amp;lt; 0) {
            exit(EXIT_FAILURE);
    }
    /* If we got a good PID, then
       we can exit the parent process. */
    if (pid &amp;amp;gt; 0) {
            exit(EXIT_SUCCESS);
    }

    /* Change the file mode mask */
    umask(0);

    /* Open any logs here */        

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &amp;amp;lt; 0) {
            /* Log the failure */
            exit(EXIT_FAILURE);
    }



    /* Change the current working directory */
    if ((chdir(&amp;quot;/&amp;quot;)) &amp;amp;lt; 0) {
            /* Log the failure */
            exit(EXIT_FAILURE);
    }

    /* Close out the standard file descriptors */
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    /* Daemon-specific initialization goes here */

    /* The Big Loop */
    while (1) {
       /* Do some task here ... */

       sleep(30); /* wait 30 seconds */
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;exit(EXIT_SUCCESS);
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;From here, you can use this &lt;a href=&#34;http://slashnude.com/t/?elsa-pataky-nude-body-of-work-in-ninette-8703&#34;&gt;nude body&lt;/a&gt; to write your own daemons. Be sure to add in your own logging (or use the syslog facility), and code defensively, code defensively, code defensively!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux 修改默认Qt版本</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/08/linux-change_default_qt_version.html</link>
      <pubDate>Sat, 08 Aug 2015 03:03:59 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/08/linux-change_default_qt_version.html</guid>
      <description>&lt;p&gt;centos 5\6 下默认使用Qt3&lt;/p&gt;

&lt;p&gt;可以通过sudo yum install qt-devel 安装qt4&lt;/p&gt;

&lt;p&gt;安装后系统默认的还是qt3&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;vim 编辑 /etc/profile.d/qt.sh 文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;lang:sh decode:true &#34; title=&#34;qt.sh 文件&#34;&gt;# Qt initialization script (sh)

# In multilib environments there is a preferred architecture, 64 bit over 32 bit in x86_64,
# When a conflict is found between two packages corresponding with different arches,
# the installed file is the one from the preferred arch. This is very common for executables
# in /usr/bin, for example. If the file /usr/bin/foo is found in an x86_64 package and in an
# i386 package, the executable from x86_64 will be installe

if [ -z &#34;${QTDIR}&#34; ]; then

case `uname -m` in
   x86_64 | ia64 | s390x | ppc64 )
      QT_PREFIXES=&#34;/usr/lib64/qt4 /usr/lib/qt4&#34; ;;
   * )
      QT_PREFIXES=&#34;/usr/lib/qt4 /usr/lib64/qt4&#34; ;;
esac

for QTDIR in ${QT_PREFIXES} ; do
  test -d &#34;${QTDIR}&#34; &amp;&amp; break
done
unset QT_PREFIXES

if ! echo ${PATH} | /bin/grep -q $QTDIR/bin ; then
   PATH=$QTDIR/bin:${PATH}
fi

QTINC=&#34;$QTDIR/include&#34;
QTLIB=&#34;$QTDIR/lib&#34;

export QTDIR QTINC QTLIB PATH

fi&lt;/pre&gt;

&lt;pre class=&#34;lang:sh decode:true &#34; title=&#34;qt.sh 文件&#34;&gt;# Qt initialization script (sh)

# In multilib environments there is a preferred architecture, 64 bit over 32 bit in x86_64,
# When a conflict is found between two packages corresponding with different arches,
# the installed file is the one from the preferred arch. This is very common for executables
# in /usr/bin, for example. If the file /usr/bin/foo is found in an x86_64 package and in an
# i386 package, the executable from x86_64 will be installe

if [ -z &#34;${QTDIR}&#34; ]; then

case `uname -m` in
   x86_64 | ia64 | s390x | ppc64 )
      QT_PREFIXES=&#34;/usr/lib64/qt4 /usr/lib/qt4&#34; ;;
   * )
      QT_PREFIXES=&#34;/usr/lib/qt4 /usr/lib64/qt4&#34; ;;
esac

for QTDIR in ${QT_PREFIXES} ; do
  test -d &#34;${QTDIR}&#34; &amp;&amp; break
done
unset QT_PREFIXES

if ! echo ${PATH} | /bin/grep -q $QTDIR/bin ; then
   PATH=$QTDIR/bin:${PATH}
fi

QTINC=&#34;$QTDIR/include&#34;
QTLIB=&#34;$QTDIR/lib&#34;

export QTDIR QTINC QTLIB PATH

fi&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;重启系统&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>linux 挂载U盘</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/08/02/linux-mountusbdisk.html</link>
      <pubDate>Sun, 02 Aug 2015 02:59:29 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/08/02/linux-mountusbdisk.html</guid>
      <description>&lt;p&gt;U盘插入后，用fdisk -l(需要管理员权限，否则为空) 查看U是否已经被识别&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果没有识别&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;         [linxux]#modprobe usb-storage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;识别之后&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再用fdisk -l 查看usb分区名字&lt;/p&gt;

&lt;p&gt;通常为/dev/sdb 开头的一个名字&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;挂载&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;[linxux]#mkdir -p /mnt/usb&lt;/p&gt;

&lt;p&gt;[linxux]#mount -t vfat /dev/sdb6 /mnt/usb&lt;/p&gt;

&lt;p&gt;***常见问题，root身份挂载之后USB分区是普通用户只读的，可以在挂载时加入参数&lt;/p&gt;

&lt;pre id=&#34;best-content-1722697460&#34; class=&#34;best-text mb-10&#34;&gt;-o umask=000&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;卸载&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;[linxux]#umount /mnt/usb&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>centos 无法找到json-c</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/07/30/centos-cantfind-json-c.html</link>
      <pubDate>Thu, 30 Jul 2015 15:46:20 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/07/30/centos-cantfind-json-c.html</guid>
      <description>

&lt;h2 id=&#34;错误信息&#34;&gt;错误信息:&lt;/h2&gt;

&lt;div&gt;
  &lt;strong&gt;package &amp;#8216;json-c&amp;#8217; not found&lt;/strong&gt;
&lt;/div&gt;

&lt;div&gt;
  &lt;p&gt;
    &lt;strong&gt;Did not find libjson&lt;/strong&gt;
  &lt;/p&gt;
  
  &lt;div&gt;
  &lt;/div&gt;
  

&lt;p&gt;&lt;h2&gt;
    解决方案：
  &lt;/h2&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-确保你已经安装了json组件&#34;&gt;1. 确保你已经安装了json组件&lt;/h3&gt;

&lt;blockquote&gt;
&lt;div&gt;
  &lt;p&gt;
    sudo yum install -y json-c json-c-devel
  &lt;/p&gt;
  
  &lt;div&gt;

  &lt;/div&gt;
  

&lt;p&gt;&lt;h3&gt;
    2. 建立符号链接
  &lt;/h3&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;div&gt;
  sudo ln -s /lib64/pkgconfig/json-c.pc /usr/lib64/pkgconfig/json-c.pc&lt;br /&gt; sudo ln -s /lib64/pkgconfig/json.pc /usr/lib64/pkgconfig/json.pc
&lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因分析&#34;&gt;原因分析：&lt;/h2&gt;

&lt;p&gt;可能是64位环境，pc文件放错位置了&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux 无法找到gengetopt</title>
      <link>http://replace-this-with-your-hugo-site.com/2015/07/30/linux_not_found_gengetopt.html</link>
      <pubDate>Thu, 30 Jul 2015 15:43:42 +0000</pubDate>
      <author>chennqqi@qq.com (chennqqi)</author>
      <guid>http://replace-this-with-your-hugo-site.com/2015/07/30/linux_not_found_gengetopt.html</guid>
      <description>

&lt;h2 id=&#34;系统没有安装gengetopt&#34;&gt;&lt;strong&gt;系统没有安装gengetopt&lt;/strong&gt;&lt;/h2&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  去gnu下载gengetopt，推荐使用华中科技大学镜像
&lt;/div&gt;

&lt;div&gt;
  &lt;a href=&#34;http://mirror.hust.edu.cn/gnu/gengetopt/&#34; target=&#34;_blank&#34;&gt;http://mirror.hust.edu.cn/gnu/gengetopt/&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;/div&gt;

&lt;div&gt;
  选择合适的版本
&lt;/div&gt;

&lt;div&gt;
  wget &lt;a href=&#34;http://mirror.hust.edu.cn/gnu/gengetopt/gengetopt-2.22.tar.g&#34; target=&#34;_blank&#34;&gt;http://mirror.hust.edu.cn/gnu/gengetopt/gengetopt-2.22.tar.g&lt;/a&gt;z
&lt;/div&gt;

&lt;div&gt;
  下载编译安装
&lt;/div&gt;

&lt;blockquote&gt;
&lt;div&gt;

&lt;/div&gt;

&lt;div&gt;
  tar xvf gengetopt-2.22.tar.gz
&lt;/div&gt;

&lt;div&gt;
  cd gengetopt-2.22
&lt;/div&gt;

&lt;div&gt;
  ./configure
&lt;/div&gt;

&lt;div&gt;
  make
&lt;/div&gt;

&lt;div&gt;
  sudo make install
&lt;/div&gt;
&lt;/blockquote&gt;

&lt;div&gt;
  补充说明：
&lt;/div&gt;

&lt;div&gt;
  如果在编译过程中出现
&lt;/div&gt;

&lt;div&gt;
  &lt;strong&gt;fileutils.cpp: In function ‘char* create_filename(char*, char*)’:&lt;/strong&gt;&lt;br /&gt; &lt;strong&gt;fileutils.cpp:23: 错误：‘strlen’在此作用域中尚未声明&lt;/strong&gt;&lt;/p&gt; 
  
  &lt;div&gt;
  &lt;/div&gt;
  

&lt;p&gt;&lt;div&gt;
    修改src/fileutils.cpp 源文件添加头文件
  &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;
    #include &lt;string.h&gt;
  &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;div&gt;
    继续编译安装即可
  &lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>